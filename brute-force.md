Εξαντλητική αναζήτηση / Brute force
===

Σε αυτό το κεφάλαιο θα δούμε πώς η πλοιοψηφία των προβλημάτων σε διαγωνισμούς πληροφορικής μπορούν να λυθούν μέσω κάποιας **εξαντλητικής μεθόδου** (*brute force*)

Έτσι, θα προσπαθήσουμε να "τυποποιήσουμε" τον τρόπο που γράφουμε μία *brute force* λύση

Αργότερα θα δούμε ότι συχνά  υπάρχουν πιο αποδοτικές λύσεις. Παρ'όλα αυτά η εξαντλητική προσέγγιση αποτελεί μια αξιόπιστη βάση μέσω της οποίας μπορούμε να οδηγηθούμε στην επιθυμιτή λύση

---

Στο προηγούμενο κεφάλαιο είδαμε πως μπορούμε να επεξεργαζόμαστε ένα ένα τα στοιχεία ενός πίνακα για να ελέγξουμε αν εμφανίζεται κάποιο στοιχείο, να υπολογίσουμε το άθροισμα τους και πολλά άλλα

Ωστόσο υπάρχουν προβλήματα για τα οποία δεν αρκεί να εξετάσουμε κάθε στοιχείο ξεχωριστά, αλλά χρειάζεται να εξετάσουμε όλες τις δυνατές πλειάδες στοιχείων (είτε ζευγάρια είτε τριάδες... ανάλογα με το πρόβλημα)  

## Πρόβλημα: [2Sum](https://leetcode.com/problems/two-sum/description/)

Δεδομένου πίνακα `nums` που αποτελείται από *n* στοιχεία και ενός ακεραίου `target` μας ζητείται να βρούμε αν υπάρχουν δύο στοιχεία του πίνακα που έχουν άθροισμα ίσο με `target`  

Παράδειγματα: 

$$target = 9, nums = [1, {\color{red} 5}, 2, {\color{red} 4}, 4, 6] \rightarrow True$$

$$target = 5, nums = [1, 3, 3, 8, 6] \rightarrow False $$

### Λύση💡

Aν με κάποιον τρόπο γνωρίζαμε το πρώτο από τα δύο στοιχεία που μας ζητείται να επιλέξουμε, έστω αυτό είναι το `nums[i]`, θα μπορούσαμε να εκτελέσουμε τον αλγόριθμο γραμμικής αναζήτησης για να ελέγξουμε αν κάποιο από τα επόμενα στοιχεία συμπληρώνει το άθροισμα που θέλουμε να δημιουργήσουμε.

Άρα αν θεωρήσουμε την θέση `i` όπου βρίσκεται το πρώτο στοιχείο γνωστή:

``` c++
bool found = 0;
for(int j = i+1; j < n; j++)
    if(nums[i] + nums[j] == target)
        found = 1;
```

Πώς όμως θα επιλέξουμε την θέση *i*?

Μπορούμε να δοκιμάσουμε κάθε πιθανή θέση *i*, δηλαδή να ελέγξουμε για κάθε *i* από 0 εώς *n-1* αν ο παραπάνω αλγόριθμος βρίσκει λύση:

``` c++
bool found = 0;
for(int i = 0; i < n; i++){
    //We fix nums[i] as our first element
    //Check if there exists a suitable second element
    for(int j = i+1; j < n; j++)
        if(nums[i] + nums[j] == target)
            found = 1;
}
```

Με τον παραπάνω τρόπο θέλουμε να έχουμε ελέγξει όλα τα πιθανά ζευγάρια στοιχείων. Πράγματι αν προσθέσουμε στο εσωτερικό *for loop* την εντολή `cout << "(" << i << ", " << j << ") "` για να δούμε ποιά ζευγάρια ελέγξαμε,

για n = 5 παίρνουμε έξοδο:

``` c++
(0, 1) (0, 2) (0, 3) (0, 4)
(1, 2) (1, 3) (1, 4)
(2, 3) (2, 4)
(3, 4)
```

### Προβληματισμοί 🔎
- Για έναν πίνακα n στοιχείων, πόσα ζευγάρια υπάρχουν?
- Πόσες τριάδες και γενικότερα, πόσες k-άδες υπάρχουν?

## Πρόβλημα: [maxSubarraySum](https://leetcode.com/problems/maximum-subarray/description/)

Δεδομένου πίνακα `a` με `n` ακεραίους βρείτε τον υποπίνακα με το μεγαλύτερο άθροισμα. Επιστρέψτε το άθροισμα αυτό

> Υποπίνακα ονομάζουμε μία **συνεχή**, μη κενή ακολουθεία που περιέχεται στον πίνακα

Παραδείγματα:

$$a = [-2,1,-3,{\red {4,-1,2,1}},-5,4] \rightarrow 6$$

$$a = [\red{5,4,-1,7,8}] \rightarrow 23$$

## Λύση 

Μπορούμε με κάποιο τρόπο να εξετάσουμε όλους τους υποπίνακες του `a`?

Παρατηρούμε ότι κάθε υποπίνακας χαρακτηρίζεται μοναδικά από τις θέσεις του πρώτου και του τελευταίου στοιχείου του

Για παραδειγμά, έστω $a = [5,4,-1,7,8]$, ο υποπίνακας του $a$ με πρώτο στοιχείο στην θέση $1$ και τελευταίο στοιχείο στην θέση $3$ είναι ο $[4,-1,7]$

Μπορούμε λοιπόν να διατρέχουμε όλα τα ζευγάρια στοιχείων $(l, r)$ όπως είδαμε σε προηγούμενο πρόβλημα. 

Έχοντας "παγώσει" *(fix)* ένα ζευγάρι, χρειάζεται να βρούμε το άθροισμα του διαστήματος στο οποίο αντιστοιχεί. 

Ο ευκολότερος τρόπος να βρίσκουμε το άθροισμα είναι να προσθέτουμε ένα ένα όλα τα στοιχεία του διαστήματος $[l, l+1, \dots ,  r-1, r]$

Συνολικά:






--- 2:10