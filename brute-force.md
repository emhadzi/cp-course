Εξαντλητική αναζήτηση / Brute force
===

Σε αυτό το κεφάλαιο θα δούμε πώς η πλοιοψηφία των προβλημάτων σε διαγωνισμούς πληροφορικής μπορούν να λυθούν μέσω κάποιας **εξαντλητικής μεθόδου** (*brute force*)

Έτσι, θα προσπαθήσουμε να "τυποποιήσουμε" τον τρόπο που γράφουμε μία *brute force* λύση

Αργότερα θα δούμε ότι συχνά  υπάρχουν πιο αποδοτικές λύσεις. Παρ'όλα αυτά η εξαντλητική προσέγγιση αποτελεί μια αξιόπιστη βάση μέσω της οποίας μπορούμε να οδηγηθούμε στην επιθυμιτή λύση

---

Στο προηγούμενο κεφάλαιο είδαμε πως μπορούμε να επεξεργαζόμαστε ένα ένα τα στοιχεία ενός πίνακα για να ελέγξουμε αν εμφανίζεται κάποιο στοιχείο, να υπολογίσουμε το άθροισμα τους και πολλά άλλα

Ωστόσο υπάρχουν προβλήματα για τα οποία δεν αρκεί να εξετάσουμε κάθε στοιχείο ξεχωριστά, αλλά χρειάζεται να εξετάσουμε όλες τις δυνατές πλειάδες στοιχείων (είτε ζευγάρια είτε τριάδες... ανάλογα με το πρόβλημα)  

## Πρόβλημα: [2Sum](https://leetcode.com/problems/two-sum/description/)

Δεδομένου πίνακα `nums` που αποτελείται από *n* στοιχεία και ενός ακεραίου `target` μας ζητείται να βρούμε αν υπάρχουν δύο στοιχεία του πίνακα που έχουν άθροισμα ίσο με `target`  

Παράδειγματα: 

$$target = 9, nums = [1, {\color{red} 5}, 2, {\color{red} 4}, 4, 6] \rightarrow True$$

$$target = 5, nums = [1, 3, 3, 8, 6] \rightarrow False $$

### Λύση💡

Aν με κάποιον τρόπο γνωρίζαμε το πρώτο από τα δύο στοιχεία που μας ζητείται να επιλέξουμε, έστω αυτό είναι το `nums[i]`, θα μπορούσαμε να εκτελέσουμε τον αλγόριθμο γραμμικής αναζήτησης για να ελέγξουμε αν κάποιο από τα επόμενα στοιχεία συμπληρώνει το άθροισμα που θέλουμε να δημιουργήσουμε.

Άρα αν θεωρήσουμε την θέση `i` όπου βρίσκεται το πρώτο στοιχείο γνωστή:

``` c++
bool found = 0;
for(int j = i+1; j < n; j++)
    if(nums[i] + nums[j] == target)
        found = 1;
```

Πώς όμως θα επιλέξουμε την θέση *i*?

Μπορούμε να δοκιμάσουμε κάθε πιθανή θέση *i*, δηλαδή να ελέγξουμε για κάθε *i* από 0 εώς *n-1* αν ο παραπάνω αλγόριθμος βρίσκει λύση:

``` c++
bool found = 0;
for(int i = 0; i < n; i++){
    //We fix nums[i] as our first element
    //Check if there exists a suitable second element
    for(int j = i+1; j < n; j++)
        if(nums[i] + nums[j] == target)
            found = 1;
}
```

Με τον παραπάνω τρόπο θέλουμε να έχουμε ελέγξει όλα τα πιθανά ζευγάρια στοιχείων. Πράγματι αν προσθέσουμε στο εσωτερικό *for loop* την εντολή `cout << "(" << i << ", " << j << ") "` για να δούμε ποιά ζευγάρια ελέγξαμε,

για n = 5 παίρνουμε έξοδο:

``` c++
(0, 1) (0, 2) (0, 3) (0, 4)
(1, 2) (1, 3) (1, 4)
(2, 3) (2, 4)
(3, 4)
```

### Προβληματισμοί 🔎
- Για έναν πίνακα n στοιχείων, πόσα ζευγάρια υπάρχουν?
- Πόσες τριάδες και γενικότερα, πόσες k-άδες υπάρχουν?


--- 1:40 