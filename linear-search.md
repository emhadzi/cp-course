LINEAR SCAN / COMPLETE SEARCH

Usual linear search, running sum/min/max
Iterate forward, backward, with step, ...

https://cses.fi/problemset/task/1069
https://pdp-archive.github.io/27-PDP/a-xxx-statement
https://pdp-archive.github.io/28-PDP/camp-j-metoxes2-statement

Can be extended for pairs (i, j), triplets(i, j, k)..., iterating over all nC2, nC3...

2Sum O(n^2) https://pdp-archive.github.io/26-PDP/c-sumpair-statement
https://leetcode.com/problems/island-perimeter/description/

Προαπαιτούμενα: Μεταβλητές, Conditionals, βασικά πινάκων

Δεδομένου ένος πίνακα *n* αριθμών, συχνά αρκεί να εξετάσουμε κάθε στοιχείο του πίνακα από μία φορά για να απαντήσουμε σε κάποια βασική ερώτηση.

Για παράδειγμα αν χρειάζεται να βρούμε το άθροισμα των στοιχείων πίνακα *a*:

``` c++
int sum = 0;
for(int i = 0; i < n; i++){
    sum += a[i];
}
```

Για να αναφερθούμε σε κάθε στοιχείο του a χρησιμοποιηούμε την μεταβλητή *i* που λειτουργεί ως δείκτης (index).

Ο δείκτης αρχικοποιείται με την τιμή 0 καθώς αυτή είναι η θέση του πρώτου στοιχείου και αυξάνεται κατά 1 όσο δεν έχει ξεπεράσει το τελευταίο στοιχείο που βρίσκεται στην θέση *n-1*

Σε αρκετά προβλήματα χρειάζεται να εξετάσουμε τα στοιχεία με συγκεκριμένη σειρά. 
Για παράδειγμα αν χρειάζεται να διατρέξουμε τον πίνακα από δεξιά προς τα αριστερά:

``` c++
for(int i = n-1; i >= 0; i--){ 
    cout << a[i] << " ";
}
```

Αν χρειάζεται να διατρέξουμε τα στοιχεία στις θέσεις 0, 2, 4, ...
``` c++
for(int i = 0; i < n; i += 2){ 
    cout << a[i] << " ";
}
```
## Πρόβλημα: getMinimum
Δίνεται πίνακας *a* με *n* ακεραίους, βρείτε τον μικρότερο από αυτούς και την θέση που εμφανίζεται

### Λύση
``` c++
int mn = a[0], minPos = 0;
for(int i = 1; i < n; i++){
    if(a[i] < mn){
        mn = a[i];
        minPos = i;
    }
}
```


## Πρόβλημα: [isIncreasing](https://www.geeksforgeeks.org/program-check-array-sorted-not-iterative-recursive/)

Έστω ένας πίνακας *a* με *n* ακεραίους να ελέγξετε αν ο *a* είναι ταξινομημένος σε αύξουσα σειρά. 

Δηλαδή ότι κάθε αριθμός είναι μεγαλύτερος ή ίσος του προηγούμενου του

### Λύση

Χρειάζεται να ελέγξουμε ότι ισχύουν όλες οι παρακάτω σχέσεις:\
`a[0] <= a[1], a[1] <= a[2], ... a[n-2] <= a[n-1]`

Άρα χρειάζεται για κάθε θέση από το *1* εώς το *n-1* να ελέγχουμε αν το αντίστοιχο στοιχείο είναι μικρότερο ή ίσο του προηγούμενου του 

Ας χρησιμοποιήσουμε μία επιπλέον μεταβλήτη `bool isIncreasing` όπου θα αποθηκεύεται το τελικό αποτέλεσμα

``` c++
bool isIncreasing = 1;
for(int i = 1; i < n; i++){
    if(a[i-1] > a[i]){
        isIncreasing = 0;
    }
}
```
Βλέπουμε ότι είναι πιο εύκολο να θεωρήσουμε αρχικά τον πίνακα ταξινομημένο `bool isIncreasing = 1;` και με το που βρούμε κάποια αντίφαση να αλλάξουμε την τιμή του *isIncreasing* σε *0* 

## Πρόβλημα: [CSES/Repetitions](https://cses.fi/problemset/task/1069)

Μας δίνεται μία συμβολοσειρά χαρακτήρων που εκφράζει μία ακολουθία *DNA*. Η συμβολοσειρά περιέχει χαρακτήρες *A*, *C*, *G* και *T*

Μας ζητείται να βρούμε το μέγεθος της μεγαλύτερης "επανάληψης" στην ακολουθία, δηλαδή το μέγεθος της μεγαλύτερης συνεχής υποσυμβολοσειράς που αποτελείται από τον ίδιο χαρακτήρα

Π.χ *ATTC<span style="color:red;">GGG</span>A* &rarr; 3

### Λύση 1

Ας λύσουμε πρώτα ένα πίο απλό πρόβλημα

Για κάποιο συγκεκριμένο σημείο στη συμβολοσειρά, πόσο πίσω μπορώ να "επεκταθώ" ώστε όλα τα στοιχεία που επιλέγω να είναι ίδια? 

Π.χ Για την συμβολοσειρά *ATTAAAACT*:

- Για την θέση 0 (*A*), δεν υπάρχει προηγούμενος χαρακτήρας *<span style="color:green;">Α</span>TTAAAACT* 
- Για την θέση 2 (*T*), μέχρι και ο προηγούμενος χαρακτήρας είναι ίδιος
*A<span style="color:green;">TT</span>TAAAACT*
- Για την θέση 5 (*A*), μέχρι και ο δευτερος προηγούμενος είναι ίδιος
*ATT<span style="color:green;">AAA</span>ACT*

Αρκεί να βρίσκουμε αυτή την τιμή για κάθε θέση του πίνακα και να επιλέγουμε την μεγαλύτερη

``` c++
string s = "ATTAAAACT";
int n = s.size(), ans = 0;
for(int i = 0; i < n; i++){
    //Δες πόσο πίσω μπορούμε να πάμε
    int j = i;
    while(j >= 0 && s[j] == s[i])
        j--;

    //Πόσους χαρακτήρες πήγαμε πίσω
    int count = i - j;
    
    //Αναναίωσε την μέγιστη εώς τώρα τιμή
    if(count > ans)
        ans = count;
}
```

### Λύση 2

Ας χωρίσουμε την συμβολοσειρά σε διαστήματα όπου όλα τα στοιχεία είναι ίδια

Ξεκινώντας από το δεύτερο στοιχείο, αν εκείνο διαφέρει από το προηγούμενο ξεκίνα καινούργιο διάστημα, αλλιώς, αν είναι ίδια, αύξησε το μέγεθος του πιο πρόσφατου διαστήματος 

*A | TT | AAAA | C | T*

Εφόσον μας ενδιαφέρει μόνο το μέγεθος του διαστήματος αρκεί να διατηρούμε σε μία μεταβλητή `int sz` το μέγεθος του τελευταίου διαστήματος

Μετά από κάθε στοιχείο που λαμβάνουμε υπόψιν, ελέγχουμε αν το διάστημα στο οποίο ανήκει είναι το μεγαλύτερο

``` c++
string s = "ATTAAAACT";
int n = s.size(), ans = 0;

//Το πρώτο στοιχείο ανοίκει στο πρώτο διάστημα
int sz = 1;

for(int i = 1; i < n; i++){
    if(a[i] == a[i-1]){
        //Αύξησε κατα 1 το μήκος του τελευταίου διάστηματος 
        sz++;
    }
    else{
        //Δημιούργησε ένα καινούργιο διάστημα στο οποίο ανήκει ο a[i]
        sz = 1;
    }
    
    //Αναναίωσε την μέγιστη εώς τώρα τιμή
    if(sz > ans)
        ans = sz;
}
```

Ποιά από τις δύο λύσεις θεωρείτε ότι είναι καλύτερη και γιατί?

Ποιά κριτήρια μπορούμε να χρησιμοποιήσουμε για να ορίσουμε πόσο "καλή" είναι μία λύση?

## Πρόβλημα [κυλικείο](https://pdp-archive.github.io/27-PDP/a-xxx-statement) 

Μια ομάδα παιδιών στέκονται σε μια ευθεία γραμμή, το ένα πίσω από το άλλο, περιμένοντας τη σειρά τους στο κυλικείο του σχολείου. Το πρώτο παιδί προφανώς βλέπει την είσοδο του κυλικείου, όσα παιδιά όμως στέκονται πίσω του δεν είναι σίγουρο ότι και αυτά τη βλέπουν. Για να βλέπει ένα παιδί την είσοδο του κυλικείου πρέπει όλα τα παιδιά που στέκονται μπροστά του να είναι κοντύτερα από αυτό.

Nα αναπτύξετε ένα πρόγραμμα που θα εκτυπώνει πόσα παιδιά βλέπουν την είσοδο.

![Κυλικείο](canteen.png)

### Λύση 1

Θα μπορούσαμε να ελέγχουμε για κάθε παιδί αν μπορεί να δεί το κυλικείο

Αρκεί να ελέγχουμε αν το συγκεκριμένο παιδί είναι ψηλότερο από όλους τους μπροστινούς του

``` c++
//Πόσα παιδία βλέπουν
int ans = 0;

for(int i = 0; i < n; i++){
    //Αρχικά θεωρώ ότι το παιδί i μπορεί να δει
    bool canSee = 1;
    
    //Ο δείκτης j κοιτάει ένα ένα τα επόμενα παιδιά μέχρι το τέλος της σειράς
    for(int j = i+1; j < n; j++){

        //Αν κάποιος μπροστινός έχει ύψος τουλάχιστον ίσο με το ύψος του παιδίου που εξετάζουμε, τότε εκείνο δεν βλέπει
        if(h[j] >= h[i])
            canSee = 0;
    }

    //Αν τελικά το παιδί i μπορεί να δει αύξησε τον μετρητή των παιδιών που βλέπουν
    if(canSee)
        ans++;
}
```
### Λύση 2
 
----

find minimum

find second minimum 

https://pdp-archive.github.io/28-PDP/camp-j-metoxes2-statement