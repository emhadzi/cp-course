LINEAR SCAN / COMPLETE SEARCH

Usual linear search, running sum/min/max
Iterate forward, backward, with step, ...

https://cses.fi/problemset/task/1069
https://pdp-archive.github.io/27-PDP/a-xxx-statement
https://pdp-archive.github.io/28-PDP/camp-j-metoxes2-statement

Can be extended for pairs (i, j), triplets(i, j, k)..., iterating over all nC2, nC3...

2Sum O(n^2) https://pdp-archive.github.io/26-PDP/c-sumpair-statement
https://leetcode.com/problems/island-perimeter/description/

Δεδομένου ένος πίνακα *n* αριθμών, συχνά αρκεί να εξετάσουμε κάθε στοιχείο του πίνακα από μία φορά για να απαντήσουμε σε κάποια βασική ερώτηση.

Για παράδειγμα αν χρειάζεται να βρούμε το άθροισμα των στοιχείων πίνακα *a*:

```
int sum = 0;
for(int i = 0; i < n; i++){
    sum += a[i];
}
```

Για να αναφερθούμε σε κάθε στοιχείο του a χρησιμοποιηούμε την μεταβλητή *i* που λειτουργεί ως δείκτης (index).

Ο δείκτης αρχικοποιείται με την τιμή 0 καθώς αυτή είναι η θέση του πρώτου στοιχείου και αυξάνεται κατά 1 όσο δεν έχει ξεπεράσει το τελευταίο στοιχείο που βρίσκεται στην θέση *n-1*

Σε αρκετά προβλήματα χρειάζεται να εξετάσουμε τα στοιχεία με συγκεκριμένη σειρά. 
Για παράδειγμα αν χρειάζεται να διατρέξουμε τον πίνακα από δεξιά προς τα αριστερά:

```
for(int i = n-1; i >= 0; i--){ 
    cout << a[i] << " ";
}
```

Αν χρειάζεται να διατρέξουμε τα στοιχεία στις θέσεις 0, 2, 4, ...
```
for(int i = 0; i < n; i += 2){ 
    cout << a[i] << " ";
}
```
## Πρόβλημα: [isIncreasing](https://www.geeksforgeeks.org/program-check-array-sorted-not-iterative-recursive/)

Έστω ένας πίνακας *a* με *n* ακεραίους να ελέγξετε αν ο *a* είναι ταξινομημένος σε αύξουσα σειρά. 

Δηλαδή ότι κάθε αριθμός είναι μεγαλύτερος ή ίσος του προηγούμενου του

### Λύση

Χρειάζεται να ελέγξουμε ότι ισχύουν όλες οι παρακάτω σχέσεις:\
`a[0] <= a[1], a[1] <= a[2], ... a[n-2] <= a[n-1]`

Άρα χρειάζεται για κάθε θέση από το *1* εώς το *n-1* να ελέγχουμε αν το αντίστοιχο στοιχείο είναι μικρότερο ή ίσο του προηγούμενου του 

Ας χρησιμοποιήσουμε μία επιπλέον μεταβλήτη `bool isIncreasing` όπου θα αποθηκεύεται το τελικό αποτέλεσμα

```
bool isIncreasing = 1;
for(int i = 1; i < n; i++){
    if(a[i-1] > a[i]){
        isIncreasing = 0;
    }
}
```
Βλέπουμε ότι είναι πιο εύκολο να θεωρήσουμε αρχικά τον πίνακα ταξινομημένο `bool isIncreasing = 1;` και με το που βρούμε κάποια αντίφαση να αλλάξουμε την τιμή του *isIncreasing* σε *0* 

## Πρόβλημα: [CSES/Repetitions](https://cses.fi/problemset/task/1069)

Μας δίνεται μία συμβολοσειρά χαρακτήρων που εκφράζει μία ακολουθία *DNA*. Η συμβολοσειρά περιέχει χαρακτήρες *A*, *C*, *G* και *T*

Μας ζητείται να βρούμε το μέγεθος της μεγαλύτερης "επανάληψης" στην ακολουθία, δηλαδή το μέγεθος της μεγαλύτερης συνεχής υποσυμβολοσειράς που αποτελείται από τον ίδιο χαρακτήρα

Π.χ *ATTC<span style="color:red;">GGG</span>A* &rarr; 3

### Λύση 1

Ας λύσουμε πρώτα ένα πίο απλό πρόβλημα

Για κάποιο συγκεκριμένο σημείο στη συμβολοσειρά, πόσο πίσω μπορώ να "επεκταθώ" ώστε όλα τα στοιχεία που επιλέγω να είναι ίδια? 

Π.χ Για την συμβολοσειρά *ATTAAAACT*:

- Για την θέση 0 (*A*), δεν υπάρχει προηγούμενος χαρακτήρας *<span style="color:green;">Α</span>TTAAAACT* 
- Για την θέση 2 (*T*), μέχρι και ο προηγούμενος χαρακτήρας είναι ίδιος
*A<span style="color:green;">TT</span>TAAAACT*
- Για την θέση 5 (*A*), μέχρι και ο δευτερος προηγούμενος είναι ίδιος
*ATT<span style="color:green;">AAA</span>ACT*

Αρκεί να βρίσκουμε αυτή την τιμή για κάθε θέση του πίνακα και να επιλέγουμε την μεγαλύτερη

```
string s = "ATTAAAACT";
int n = s.size(), ans = 0;
for(int i = 0; i < n; i++){
    //Δες πόσο πίσω μπορούμε να πάμε
    int j = i;
    while(j > 0 && s[j] == s[i])
        j--;

    //Πόσους χαρακτήρες πήγαμε πίσω
    int count = i - j;
    
    //Αναναίωσε την μέγιστη εώς τώρα τιμή
    if(count > ans)
        ans = count;
}
```

### Λύση 2

Ας χωρίσουμε την συμβολοσειρά σε διαστήματα όπου όλα τα στοιχεία είναι ίδια

Ξεκινώντας από το δεύτερο στοιχείο, αν εκείνο διαφέρει από το προηγούμενο ξεκίνα καινούργιο διάστημα, αλλιώς, αν είναι ίδια, αύξησε το μέγεθος του πιο πρόσφατου διαστήματος 

*A | TT | AAAA | C | T*

Εφόσον μας ενδιαφέρει μόνο το μέγεθος του διαστήματος αρκεί να διατηρούμε σε μία μεταβλητή `int sz` το μέγεθος του τελευταίου διαστήματος

Μετά από κάθε στοιχείο που λαμβάνουμε υπόψιν, ελέγχουμε αν το διάστημα στο οποίο ανήκει είναι το μεγαλύτερο

```
string s = "ATTAAAACT";
int n = s.size(), ans = 0;

//Το πρώτο στοιχείο ανοίκει στο πρώτο διάστημα
int sz = 1;

for(int i = 1; i < n; i++){
    if(a[i] == a[i-1]){
        //Αύξησε κατα 1 το μήκος του τελευταίου διάστηματος 
        sz++;
    }
    else{
        //Δημιούργησε ένα καινούργιο διάστημα στο οποίο ανήκει ο a[i]
        sz = 1;
    }
    
    //Αναναίωσε την μέγιστη εώς τώρα τιμή
    if(sz > ans)
        ans = sz;
}
```

Ποιά από τις δύο λύσεις θεωρείται ότι είναι καλύτερη και γιατί




